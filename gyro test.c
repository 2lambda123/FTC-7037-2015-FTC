#pragma config(Hubs,  S1, HTMotor,  HTServo,  none,     none)
#pragma config(Sensor, S2,     Gyro,           sensorI2CHiTechnicGyro)
#pragma config(Sensor, S3,     light,          sensorLightActive)
#pragma config(Sensor, S4,     sonar,          sensorSONAR)
#pragma config(Motor,  mtr_S1_C1_1,     rightMotor,    tmotorTetrix, openLoop, reversed, driveRight, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     leftMotor,     tmotorTetrix, openLoop, driveLeft, encoder)
#pragma config(Servo,  srvo_S1_C2_1,    servo1,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
#define MIN(a,b) (((a)<(b))?(a):(b))
#define MAX(a,b) (((a)>(b))?(a):(b))
float map(float x, float in_min, float in_max, float out_min, float out_max)
{
return (x-in_min)*(out_max-out_min)/(in_max- in_min)+ out_min;
}

//void turn(int Target)
//{
//	//take initial reading
//	int speed=50;
//	int KD=60;//momentum tuning
//	float ProcessValue=0;
//	int InitVal=(SensorValue[gyro]+KD)*10;
//	writeDebugStreamLine("InitVal:%d",InitVal);
////which direction
//		if(Target>0)//positating==counterClockwise or left
//		{
//		writeDebugStreamLine("turning left");
//		//start turning left
//		motor[rightMotor]=speed;
//		motor[leftMotor]=-speed;
//		writeDebugStreamLine("motors on");
//			//check if turn is achieved
//				while(ProcessValue<Target)//hold execution flow until we get to target
//				{
//					writeDebugStreamLine("checking Gyro:%d", ProcessValue);
//					wait1Msec(10);// 0.01 seconds
//					int CurrentReading=(SensorValue[gyro]*10)-InitVal;
//					ProcessValue =(-1*(ProcessValue+CurrentReading)* 0.01);//distance = rate*time
//				}
//		// stop motors when target achived
//			writeDebugStreamLine("motors off");
//			motor[rightMotor]=0;
//			motor[leftMotor]=0;
//		}
//	}

	void SetSpeed(int Leftspeed, int Rightspeed)
	{
	motor[leftMotor]=Leftspeed;
	motor[rightMotor]=Rightspeed;
	}

	void Drive(float outputMagnitude, float curve)//(-1,+1) all
 {
					clearDebugStream();
         float leftOutput, rightOutput=0.0;
         float m_sensitivity=0.3;//tuning value KP
         float value;
         float ratio;
         if (curve < 0)
         {
                  value = log(-curve);
                  ratio = (value - m_sensitivity)/(value + m_sensitivity);
                 if (ratio == 0) ratio =.0000000001;
                 leftOutput = outputMagnitude / ratio;
                 rightOutput = outputMagnitude;
         }
         else if (curve > 0)
         {
                  value = log(curve);
                  ratio = (value - m_sensitivity)/(value + m_sensitivity);
                 if (ratio == 0) ratio =.0000000001;
                 leftOutput = outputMagnitude;
                 rightOutput = outputMagnitude / ratio;
         }
         else
         {
                 leftOutput = outputMagnitude;
                 rightOutput = outputMagnitude;
         }
         SetSpeed(leftOutput*100,rightOutput*100);//(-100, +100)
         writeDebugStreamLine("curve:%f, leftOutput:%f, rightOutput:%f, value:%f, ratio%f",curve, leftOutput*100, rightOutput*100, value, ratio);
 }
void Drive(int Distance)
{
	float speed = 0.5;
	float C=2*(PI)*2;//wheel circum frence
  float Angle=0;// what we will use to hold angle during our loop
  float Kp =0.03;//gain, rate of change, 0-100.
	float circumfrence = 2*(PI)*2;
	float WheelbaseRadius = 7.3875;
	int Kd=60;//momentum tuning
	int direction=0;
	int ppr =1120;
	int	Target =(ppr/C)*Distance;//encoder target counts
	int enc_in=ppr/circumfrence;//result

	if(Distance>0)//forward
	{
		nMotorEncoder[leftMotor]=0;
		nMotorEncoder[rightMotor]=0;
		while(Target>nMotorEncoder[leftMotor])
		{
			//reset encoders
			int Lenc=nMotorEncoder[leftMotor];
			int Renc=nMotorEncoder[rightMotor];
		//check direction
			if(Lenc>Renc)//veering right
			{
				direction=1;
			}
			else if(Lenc<Renc)//veering left
			{
				direction=-1;
			}
		//find angle
			int Y=enc_in*(MAX(Lenc, Renc)-MIN(Lenc, Renc));//the length of difference betwwen encoders
			int H=WheelbaseRadius*2;//longest leg of the triangle
			int X=sqrt(Y^2+H^2)*direction;//distance from horizontal square.
			float preangle=sinDegrees(X/H);
	 		Angle= map(preangle,-90,90,-1,1);
			writeDebugStream("angle:%f", angle);
			Drive(speed,angle);
		}
	}
	if(Distance<0)//reverse
	{

	}
}

task main()
{
	while (true)
	{
	Drive(12);
	}
}
//Drive(10);
