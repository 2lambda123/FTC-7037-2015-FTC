#pragma config(Hubs, S1, HTMotor, HTServo, none, none)
#pragma config(Sensor, S1, , sensorI2CMuxController)
#pragma config(Sensor, S2, Gyro, sensorI2CHiTechnicGyro)
#pragma config(Sensor, S3, light, sensorLightActive)
#pragma config(Sensor, S4, sonar, sensorSONAR)
#pragma config(Motor, mtr_S1_C1_1, rightMotor, tmotorTetrix, openLoop,         \
               reversed, driveRight, encoder)
#pragma config(Motor, mtr_S1_C1_2, leftMotor, tmotorTetrix, openLoop,          \
               driveLeft, encoder)
#pragma config(Servo, srvo_S1_C2_1, servo1, tServoNone)
#pragma config(Servo, srvo_S1_C2_2, servo2, tServoNone)
#pragma config(Servo, srvo_S1_C2_3, servo3, tServoNone)
#pragma config(Servo, srvo_S1_C2_4, servo4, tServoNone)
#pragma config(Servo, srvo_S1_C2_5, servo5, tServoNone)
#pragma config(Servo, srvo_S1_C2_6, servo6, tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard !!*//
#pragma DebuggerWindows("debugStream")
// nMotorPIDSpeedCtrl[Right] = mtrSpeedReg;  // enable PID
// nMotorPIDSpeedCtrl[Left] = mtrSpeedReg;  // enable PID
#define MIN(a, b) (((a) < (b)) ? (a) : (b))
#define MAX(a, b) (((a) > (b)) ? (a) : (b))
float map(float x, float in_min, float in_max, float out_min, float out_max) {
  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
}
void SetSpeed(int Leftspeed, int Rightspeed) {
  // Leftspeed=map(Leftspeed,-100,100,-78,78);//for use with built in PID
  // Rightspeed=map(Rightspeed,-100,100,-78,78);//for use with built in PID
  motor[leftMotor] = Leftspeed;
  motor[rightMotor] = Rightspeed;
}

void Drive(float outputMagnitude, float curve) //(-1,+1) all
{
  float leftOutput, rightOutput = 0.0;
  float m_sensitivity = 0.3; // tuning value KP
  float value = 0;
  float ratio = 0;
  if (curve < 0) {
    value = log(-1 * curve);
    ratio = (value - m_sensitivity) / (value + m_sensitivity);
    if (ratio == 0)
      ratio = .0000000001;
    leftOutput = outputMagnitude;
    rightOutput = outputMagnitude / ratio;
  } else if (curve > 0) {
    value = log(curve);
    ratio = (value - m_sensitivity) / (value + m_sensitivity);
    if (ratio == 0)
      ratio = .0000000001;
    leftOutput = outputMagnitude / ratio;
    rightOutput = outputMagnitude;
  } else {
    leftOutput = outputMagnitude;
    rightOutput = outputMagnitude;
  }
  SetSpeed(round(leftOutput * 100), round(rightOutput * 100)); //(-100, +100)
  writeDebugStreamLine(
      " curve:%f, leftOutput:%f, rightOutput:%f, value:%f, ratio:%f ", curve,
      round(leftOutput * 100), round(rightOutput * 100), value, ratio);
}
void Drive(int Distance) // working virtual *5/4/15*
{

  /****************************************************************************************
  this function is meant to correct for drift using a proportional
  controller.(P) from PID. If properly used the funtion WILL correct for minor
  drift Within 1/100degree acuracy.
  ****************************************************************************************/
  // constants used to compute drift
  float speed = 0.5;
  float Angle = 0; // what we will use to hold angle during our loop
  float Kp = 1.25; // gain, rate of change, 0-100.
  float WheelbaseRadius = 6.69; // Robot virtual worlds "conveyor bot"
  // float WheelbaseRadius = 7.3875;// Robot: Team #7037 "Ada" 2015

  // calculate encoder target from distance
  float C = 2 * (PI) * 2; // wheel circumfrence
  int ppr = 1120;
  float enc_in = ppr / C;
  int Target = enc_in * Distance; // encoder target counts

  // used for orientation
  int direction = 0;
  int ProcessValue = 0;
  // reset encoderes
  nMotorEncoder[leftMotor] = 0;
  nMotorEncoder[rightMotor] = 0;
  // determine orintetion
  if (Distance > 0) // forward
  {
    while (Target > ProcessValue) // will change to (target<processvalue)
    {
      // update and adjust encoders
      int Lenc = -1 * nMotorEncoder[leftMotor];
      int Renc = -1 * nMotorEncoder[rightMotor];
      ProcessValue = Lenc + Renc / 2; // average distace traveled
      // writeDebugStreamLine("Lenc: %i, Renc: %i", Lenc,Renc);//check to make
      // sure both encoderds positating, sanity check check for deviation
      if (Lenc > Renc) // veering right
      {
        direction = 1;        // poitive
      } else if (Lenc < Renc) // veering left
      {
        direction = -1; // negitive
      }
      // find angle of deviation
      int Y =
          round(enc_in * (MAX(Lenc, Renc) -
                          MIN(Lenc, Renc))); // the difference between encoders
      int H = WheelbaseRadius * 2;           // distance between wheels
      int X = sqrt(Y ^ 2 + H ^ 2) *
              direction; // how far deviated in what direction (not entirely
                         // true but close enough)
      float preangle =
          sinDegrees(X / H); // will later be used for porportional control
      Angle = map(preangle, 0, 0.9, 0, 187); // for humans
      writeDebugStreamLine("angle:%f, preangle:%f", Angle,
                           preangle); // for humans
      // start moving and correct for drift porportionaly using angle
      Drive(speed, preangle * Kp); // this is basic porportional control
    } // end of loop
  }
  if (Distance < 0) // reverse
  {
    // needs to be written...
  }
} // end of funtion

task main() {
  clearDebugStream();
  Drive(10);
}
// Drive(10);
