#pragma config(Hubs,  S1, HTMotor,  HTServo,  none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Motor,  mtr_S1_C1_1,     Right,         tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     Left,          tmotorTetrix, openLoop, encoder)
#pragma config(Servo,  srvo_S1_C2_1,    servo1,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma DebuggerWindows("debugStream")
#include "drivers/PID.h"

void Drive(int distance);

task main()
{
    Drive(20);
}

void Drive(int distance)
{
    int C=2*(PI)*2;
    int Target= (1120/C)*distance;//en/in
    nMotorEncoder[motorE]=0;
    nMotorEncoder[motorD]=0;

    //motor[Left]= 100;
    //motor[Right]=100;
    while(true)
    {
        Motor[left]=PID(Target, nMotorEncoder[left]);//set one motor to Target
        writeDebugStreamLine("PID:%i, Target:%i,	Left:%i,	Right:%i",	PID(Target, nMotorEncoder[Left]),	Target, -1*nMotorEncoder[Left],	nMotorEncoder[Right]);
    }
//Motor[Left]= PID( nMotorEncoder[Right], nMotorEncoder[Left]); //set the other as slave, one encoder will be backward, FIX ME
    //motor[Right]=PID(Target, nMotorEncoder[Left]);

    writeDebugStreamLine("PID:%i, Target:%i,	Left:%i,	Right:%i",	PID(Target, nMotorEncoder[Left]),	Target, -1*nMotorEncoder[Left],	nMotorEncoder[Right]);

}
