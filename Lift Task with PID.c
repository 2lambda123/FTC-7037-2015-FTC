#pragma config(Hubs,  S1, HTMotor,  HTServo,  HTMotor,  HTMotor)
#pragma config(Sensor, S2,     IRLeft,         sensorHiTechnicIRSeeker1200)
#pragma config(Sensor, S3,     Compass,        sensorI2CHiTechnicCompass)
#pragma config(Sensor, S4,     HTSPB,          sensorI2CCustom9V)
#pragma config(Motor,  motorA,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorB,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorC,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  mtr_S1_C1_1,     Right,         tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     Left,          tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C3_1,     Intake,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     none,          tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_1,     Conveyor,      tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_2,     Lift,          tmotorTetrix, PIDControl, encoder)
#pragma config(Servo,  srvo_S1_C2_1,    Gripper,              tServoStandard)
#pragma config(Servo,  srvo_S1_C2_2,    lock,                 tServoContinuousRotation)
#pragma config(Servo,  srvo_S1_C2_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "drivers/HTSPB-driver.h"
#include "drivers/PID.h"
int hasbeeninit = 0;
bool SwitchState =false;//initialize switchstate as false

void RunLift(short nStage)
{
    int inputdata = HTSPBreadADC(HTSPB, 0, 10);
    //the first time in a program this is called, initialize the lift
    if(hasbeeninit==0)	//initialize the lift
    {
//initialize the lift
        motor[Lift]=100;
        wait1Msec(500);
        motor[Lift]=0;
        while(true)
        {
            //check switch state
            int inputdata = HTSPBreadADC(HTSPB, 0, 10);//refreshed per cycle.
            SwitchState = (int)inputdata >512;//boolean algebra.

            if(inputdata==-1)//this is the fault state for the HTSPB reading analog.
            {
                //report error
                writeDebugStreamLine("S4 Fault");
                nxtDisplayCenteredBigTextLine(3, "S4 Fault");
                break;	//exit the function
            }
            if(SwitchState==false)//if switch open
            {
                //move down until switch is pressed
                motor[Lift]=-20;
                writeDebugStreamLine("STATE:%i",SwitchState);
            }
            else if(SwitchState==true)// if switch closed
            {
                motor[Lift]=0;
                nMotorEncoder[Lift]=0;
                writeDebugStreamLine("STATE:%i",SwitchState);
                break;//exit and begin PID controll
            }
        }
//confirm initialization
        hasbeeninit= -1;//keeps from initializing more than once
        writeDebugStreamLine("STATE:%i",SwitchState);//reports switch information
        writeDebugStreamLine("initialization complete");
    }
    wait10Msec(100);
//determine target for PID
    float Range=22.5;//mechanical rotations of the motor shaft to extend full length of lift
    float Stages=4;//number of stages
    float ppr= 1120;//pulse per revolution for the andymark motor
    float nTarget=(nStage/Stages)*(Range *ppr);

    //loop until within tolerance.
    while(abs(nTarget-nMotorEncoder[Lift])>Tolerance+5)//--TEST added 5 becuase Tolerance to low?
    {
        writeDebugStreamLine("Target:%i, status:%i",nTarget, nMotorEncoder[Lift]);
        motor[Lift]=PID(nTarget,nMotorEncoder[Lift]);
    }
    motor[Lift]=0;


    //************************************LOGIC-TEST************************************//
    //int SIM =0;
    //while(abs(nTarget-SIM)>Tolerance)
    //{
    //	writeDebugStreamLine("Target:%i, status:%i",nTarget, SIM);
    //	motor[Lift]=PID(nTarget,SIM);
    //	SIM++;
    //	SIM++;
    //	wait1Msec(2);
    //	clearDebugStream();
    //}
    //motor[Lift]=0;
    //*********************************************************************************//
    return;
}

task main()
{
    RunLift(2);
    wait10Msec(300);
    writeDebugStream("Proceedural success")
}
